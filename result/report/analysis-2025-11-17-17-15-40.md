目标 URL: http://target.com/easy.php

# JavaScript 加解密分析报告

```markdown
## 1. 加解密方法识别

### 📌 加密函数：`sendDataAes(url)`
- **调用位置**：通过按钮 `onclick` 事件触发（脚本ID:16, 行131）
- **功能描述**：收集表单数据，使用 AES-CBC 对 JSON 数据进行加密，并通过 POST 请求发送。
- **调用链**：
```
  onclick(event) → sendDataAes("encrypt/aes.php")
  ```

### 🔐 加密算法分析
| 属性         | 值                             |
|--------------|----------------------------------|
| 算法类型     | 对称加密                         |
| 具体算法     | AES (Advanced Encryption Standard) |
| 模式         | CBC (Cipher Block Chaining)      |
| 填充方式     | PKCS7                          |
| 密钥长度     | 128 bits                        |
| 数据格式     | UTF-8 编码字符串转 CryptoJS WordArray |

✅ 使用了 **CryptoJS** 库实现加密：
```js
CryptoJS.AES.encrypt(jsonData, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 })
  ```

> ⚠️ 注意：IV 与 Key 相同（均为 `"1234567890123456"`），存在安全隐患，但在此场景中为静态配置。

---

## 2. 密钥提取

### 🔑 密钥信息（明文硬编码）
| 参数 | 值（字符串）       | Hex 编码                         | Base64 编码                   |
|------|--------------------|-----------------------------------|-------------------------------|
| Key  | `1234567890123456` | `31323334353637383930313233343536` | `MTIzNDU2Nzg5MDEyMzQ1Ng==`   |
| IV   | `1234567890123456` | `31323334353637383930313233343536` | `MTIzNDU2Nzg5MDEyMzQ1Ng==`   |

- **密钥来源**：直接在 JS 中硬编码，无动态生成或派生逻辑
- **存储位置**：内存中解析为 `CryptoJS.lib.WordArray` 对象（sigBytes=16）
- **安全性评估**：极低 —— 静态密钥 + IV = 可预测加密输出

---

## 3. 关键代码分析

### ✅ 核心加解密逻辑还原（简化注释版）

```javascript
function sendDataAes(url) {
    // 1. 获取表单数据
    const formData = {
        username: document.getElementById("username").value,
        password: document.getElementById("password").value
    };

    // 2. 转为 JSON 字符串
    const jsonData = JSON.stringify(formData);

    // 3. 定义固定密钥和 IV（128位）
    const key = CryptoJS.enc.Utf8.parse("1234567890123456");
    const iv  = CryptoJS.enc.Utf8.parse("1234567890123456");

    // 4. AES-128-CBC 加密 + PKCS7 填充
    const encrypted = CryptoJS.AES.encrypt(jsonData, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    }).toString();

    // 5. URL 编码后作为参数提交
    const params = `encryptedData=${encodeURIComponent(encrypted)}`;

    // 6. 发送 POST 请求
    fetch(url, {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded; charset=utf-8"
        },
        body: params
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = "success.html";
        } else {
            alert("用户名或密码错误");
        }
    })
    .catch(error => {
        console.error("请求错误:", error);
    })
    .finally(() => {
        closeModal();
    });
}
```

### 🧩 混淆与执行分析
- 无明显混淆（变量名清晰、逻辑直白）
- 未使用 `eval` / `Function` 动态执行
- 所有加密操作同步完成，便于调试和 Hook

---

## 4. mitmproxy 脚本实现（Python）

以下脚本可自动解密请求内容并记录原始明文：

```python
# aes_decrypt_mitm.py
from mitmproxy import http
import urllib.parse
import json
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

# 固定密钥和 IV（UTF-8 编码）
KEY = b"1234567890123456"
IV = b"1234567890123456"

def decrypt_aes_cbc_b64(encrypted_data: str) -> str:
    """
    解密 Base64 编码的 AES-CBC 数据（PKCS7 填充）
    """
    try:
        # Step 1: URL Decode
        encrypted_data = urllib.parse.unquote(encrypted_data)
        
        # Step 2: Base64 decode ciphertext
        ciphertext = urllib.parse.unquote_to_bytes(encrypted_data)
        
        cipher = AES.new(KEY, AES.MODE_CBC, IV)
        decrypted = cipher.decrypt(ciphertext)
        
        # Remove PKCS7 padding
        unpadded = unpad(decrypted, AES.block_size, style='pkcs7')
        
        return unpadded.decode('utf-8')
    except Exception as e:
        return f"[解密失败] {str(e)}"

def request(flow: http.HTTPFlow):
    if "encrypt/aes.php" in flow.request.pretty_url and flow.request.method == "POST":
        content_type = flow.request.headers.get("Content-Type", "")
        if "application/x-www-form-urlencoded" in content_type:
            body = flow.request.get_text()
            params = urllib.parse.parse_qs(body)
            encrypted_data_list = params.get("encryptedData", [])
            
            if encrypted_data_list:
                encrypted_data = encrypted_data_list[0]
                plaintext = decrypt_aes_cbc_b64(encrypted_data)
                
                # 注入明文到请求头，供后续查看
                flow.request.headers["X-Decrypted-Data"] = plaintext
                print(f"[+] 解密成功: {plaintext}")
```

### 🛠 使用说明
1. 安装依赖：
   ```bash
   pip install mitmproxy pycryptodome
   ```

2. 启动代理：
   ```bash
   mitmdump -s aes_decrypt_mitm.py
   ```

3. 浏览器/设备设置代理至 `localhost:8080`，访问目标页面

4. 查看控制台输出解密后的明文数据，如：
   ```
   [+] 解密成功: {"username":"121","password":"1221"}
   ```

---

## 总结

| 项目             | 分析结果                                               |
|------------------|--------------------------------------------------------|
| 加密方式         | AES-128-CBC with PKCS7 Padding                         |
| 密钥管理         | 明文硬编码，Key 和 IV 相同，严重不安全                 |
| 数据流向         | 前端加密 → POST 提交 → 后端解密                        |
| 可破解性         | 极高 —— 已知 Key/IV，可完全逆向                         |
| mitmproxy 支持   | ✅ 支持实时解密，无需浏览器插件                         |

> 💡 本系统仅提供基础传输混淆，不具备实际安全防护能力。建议仅用于学习或测试环境分析。

```